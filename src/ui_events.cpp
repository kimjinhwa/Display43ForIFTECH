// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.3.4
// LVGL version: 8.3.3
// Project name: SquareLine_Project

#include "ui.h"
#include "main.h"
#include "mainGrobal.h"
#include <EEPROM.h>
#include <RtcDS1302.h>
#include "lv_i18n.h"
#include "upsLog.h"
#include <sstream>
#include <Arduino_GFX_Library.h>
//#include "string.h"
//#include <cstring>
extern upsLog  upslogEvent;
extern upsLog  upslogAlarm;
extern bool data_ready ;

enum TextId {
	UPSONOFF=6,
	BATCURR_REF=8,
	BATVOL_REF=9,
	OUTPUTVOL_REF=10,
	HFMODE=11,
	INPUTVOLTGAIN = 38,
	INPUTCURRGAIN = 39,
	VDCLINKVOLTGAIN = 40,
	VBATVOLTGAIN = 41,
	BAT_CURRENT_GAIN= 42,
	INVERTER_VOLT_GAIN= 43,
	INVERTER_CURRENT_GAIN= 44,
	OUTPUT_CURRENT_GAIN= 46,
	EVENTTXTOFFTIME_ = 12,
	BRIGHTNESSCONSTRAIN_ = 13,
	SYSTEMYEAR= 60,
	SYSTEMMONTH= 61,
	SYSTEMDAY= 62,
	SYSTEMHOUR= 63,
	SYSTEMMINUTE= 64,
	SYSTEMSECOND =65 
};
enum TIMESAVE {
	S_YEAR = 1,
	S_MONTH = 2,
	S_DAY = 3,
	S_HOUR = 4,
	S_MIN = 5,
	S_SEC = 6
};
int WriteHoldRegistor(int index,int value,uint32_t Token);
void enqueueModbusCommand(int index, int value, uint32_t token) ;
void showMessageLabel(const char *message);
void timeSave(TIMESAVE tType,int16_t value);
void scrSettingScreen();
void setLogTextArea(lv_obj_t *obj,upsLog  *upslog,directionType_t direction);

uint32_t waitDataReceive(int wCount);
uint32_t getReceiveToken();
uint32_t getDataReady ();
lv_obj_t *ui_txtTempory ;

// void change_tab_name(lv_obj_t * tab, const char * new_name) {
//     lv_obj_t * tab_label = lv_obj_get_child(tab, 0); // 탭의 첫 번째 자식 객체가 라벨 객체임
//     if (tab_label != NULL && lv_obj_check_type(tab_label, &lv_label_class)) {
//         lv_label_set_text(tab_label, new_name);
//     }
// }
void parseStringByLine(lv_obj_t *obj, const char *source /*,std::vector<std::string>*newStr*/)
{
	std::string retStr(source);
	std::vector<std::string> newStr;
	std::istringstream iss(retStr);
	std::string line;
	lv_textarea_set_text(obj,"");//기존 데이타를 클리어 하고
	while (std::getline(iss, line, '\n'))
	{
		newStr.push_back(line);
	}
	retStr="";
	for (const auto &str : newStr)
	{
		retStr.append( _(str.c_str()));
		retStr.append("\n");
	}
	lv_textarea_set_text(obj, retStr.c_str());
}
void mainScrUpdata();
extern Arduino_RPi_DPI_RGBPanel *gfx ;
void ChangeLanguage(lv_event_t * e)
{
	if(strcmp("ko-KR", lv_i18n_get_current_locale()) == 0 ){
    	lv_i18n_set_locale("en-GB");
		nvsSystemEEPRom.systemLanguage = 2;
	}
    else 	
	{
		lv_i18n_set_locale("ko-KR");
		nvsSystemEEPRom.systemLanguage = 1;
	}
    EEPROM.writeBytes(1, (const byte *)&nvsSystemEEPRom, sizeof(nvsSystemSet_t));
    EEPROM.commit();
	esp_restart();
	//showMessageLabel(_("REBOOT"));
  	lv_timer_handler(); 

  	lv_init();
	ui_init();
}

void evtTabUpsSetup(lv_event_t * e)
{
	ESP_LOGI("SET","Tab upsSetup clicked");
    //lv_obj_add_flag(ui_batSaveSetting, LV_OBJ_FLAG_HIDDEN );     /// Flags
}
void evtTabGainSetup1(lv_event_t * e)
{
	ESP_LOGI("SET","Tab setup1 clicked");
    //lv_obj_add_flag(ui_batSaveSetting, LV_OBJ_FLAG_HIDDEN );     /// Flags
}

void evtTabGainSetup2(lv_event_t * e)
{
	ESP_LOGI("SET","Tab setup2 clicked");
    //lv_obj_add_flag(ui_batSaveSetting, LV_OBJ_FLAG_HIDDEN );     /// Flags
}

void EventTabCliekEvent(lv_event_t *e){
	ESP_LOGI("EVT","EventTabCliekEvent");
	setLogTextArea(ui_eventTextArea,&upslogEvent,CURRENTLOG);
	setLogTextArea(ui_alarmTextArea,&upslogAlarm,CURRENTLOG);
}
void AlarmTabCliekEvent(lv_event_t *e){
	ESP_LOGI("EVT","AlarmTabCliekEvent");
	setLogTextArea(ui_eventTextArea,&upslogEvent,CURRENTLOG);
	setLogTextArea(ui_alarmTextArea,&upslogAlarm,CURRENTLOG);
}

void evtSystemTabClicked(lv_event_t *e)
{
	timeval tmv;
	gettimeofday(&tmv, NULL);
	RtcDateTime nowTime = RtcDateTime(tmv.tv_sec);
	// ESP_LOGI("SET","systemLedOffTime %d lcdBright %d",
	// 	nvsSystemEEPRom.systemLedOffTime,nvsSystemEEPRom.lcdBright);
    // lv_textarea_set_text(ui_txtOfftime, String(nvsSystemEEPRom.systemLedOffTime).c_str());
    // lv_textarea_set_text(ui_txtBrigtness, String(nvsSystemEEPRom.lcdBright).c_str());

	lv_textarea_set_text(ui_txtYear, String(nowTime.Year()-2000).c_str());
	lv_textarea_set_text(ui_txtMonth, String(nowTime.Month()).c_str());
	lv_textarea_set_text(ui_txtDay, String(nowTime.Day()).c_str());
	lv_textarea_set_text(ui_txtHour, String(nowTime.Hour()).c_str());
	lv_textarea_set_text(ui_txtMinute, String(nowTime.Minute()).c_str());
	lv_textarea_set_text(ui_txtSecond, String(nowTime.Second()).c_str());

	lv_textarea_set_text(ui_txtOfftime, String(nvsSystemEEPRom.systemLedOffTime).c_str());
	lv_textarea_set_text(ui_txtBrigtness, String(nvsSystemEEPRom.lcdBright).c_str());

	//lv_obj_add_flag(ui_lblMessage,LV_OBJ_FLAG_HIDDEN);
	//lv_obj_clear_flag(ui_batSaveSetting,LV_OBJ_FLAG_HIDDEN );
	//_ui_flag_modify( ui_batSaveSetting , LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
	ESP_LOGI("SET","Tab System clicked");
}
void showMessageLabel(const char *message)
{
	lv_obj_t * current_screen = lv_scr_act();
    lv_obj_set_parent( ui_lblMessage,current_screen );

	lv_label_set_text( ui_lblMessage,message);
	_ui_flag_modify( ui_lblMessage, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
}
void evtMessageLblClick(lv_event_t * e){
	lv_obj_add_flag(ui_lblMessage,LV_OBJ_FLAG_HIDDEN);
	//_ui_flag_modify( ui_lblMessage, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
}
void setRtcNewTime(RtcDateTime rtc);
void timeSave(TIMESAVE tType,int16_t value){
	// timeval tmv;
	tm nowTime;
	nowTime.tm_year = String(lv_textarea_get_text(ui_txtYear)).toInt() +2000  ;
	nowTime.tm_mon = String(lv_textarea_get_text(ui_txtMonth)).toInt();
	nowTime.tm_mday = String(lv_textarea_get_text(ui_txtDay)).toInt();
	nowTime.tm_hour = String(lv_textarea_get_text(ui_txtHour)).toInt();
	nowTime.tm_min = String(lv_textarea_get_text(ui_txtMinute)).toInt();
	nowTime.tm_sec = String(lv_textarea_get_text(ui_txtSecond)).toInt();
	switch (tType)
	{
	case S_YEAR :
		nowTime.tm_year = value +2000  ;
		break;
	case S_MONTH:
		nowTime.tm_mon = value;
		break;
	case S_DAY:
		nowTime.tm_mday = value;
		break;
	case S_HOUR:
		nowTime.tm_hour = value;
		break;
	case S_MIN:
		nowTime.tm_min = value;
		break;
	case S_SEC:
		nowTime.tm_sec = value;
		break;
	default:
		break;
	}
	RtcDateTime nowRtc = RtcDateTime(nowTime.tm_year,nowTime.tm_mon,nowTime.tm_mday,nowTime.tm_hour,nowTime.tm_min,nowTime.tm_sec);
 	ESP_LOGI("Set Rtc","Set Rtc %d-%d-%d %d:%d:%d",
			nowTime.tm_year,nowTime.tm_mon,nowTime.tm_mday,
			nowTime.tm_hour,nowTime.tm_min,nowTime.tm_sec);
	setRtcNewTime(nowRtc );
}


void TabEvtNextClick(lv_event_t * e)
{
	lv_tabview_set_act(ui_TabView1,2,LV_ANIM_OFF);
}
void TabEvtPrevClick(lv_event_t * e)
{
	lv_tabview_set_act(ui_TabView1,1,LV_ANIM_OFF);
}

void TabEvtOffsetClick(lv_event_t * e)
{
	lv_tabview_set_act(ui_TabView1,3,LV_ANIM_OFF); //TabGainSetup3
}
void TabEvtESCClick(lv_event_t * e)
{
	uint16_t selectedTab=0;
	selectedTab = lv_tabview_get_tab_act(ui_TabView1);
	ESP_LOGW("UI","Tab selected %d",selectedTab);
	if(selectedTab == 3)  // 옵셋화면이면..
	lv_tabview_set_act(ui_TabView1,1,LV_ANIM_OFF);
	else 
	lv_tabview_set_act(ui_TabView1,0,LV_ANIM_OFF);
}
void TabEventSetupVolClick(lv_event_t * e)
{
	lv_tabview_set_act(ui_TabView1,1,LV_ANIM_OFF);
}

void TabEvtSystemGoBackClick(lv_event_t * e){
	uint16_t selectedTab=0;
	lv_tabview_set_act(ui_TabView1,4,LV_ANIM_OFF);
	selectedTab = lv_tabview_get_tab_act(ui_TabView1);
	ESP_LOGW("UI","Tab selected %d",selectedTab);
}
void TabEvtSystemSetClick(lv_event_t * e){
	uint16_t selectedTab=0;
	lv_tabview_set_act(ui_TabView1,5,LV_ANIM_OFF);
	selectedTab = lv_tabview_get_tab_act(ui_TabView1);
	ESP_LOGW("UI","Tab selected %d",selectedTab);
	ESP_LOGI("SET","systemLedOffTime %d lcdBright %d",
		nvsSystemEEPRom.systemLedOffTime,nvsSystemEEPRom.lcdBright);
    lv_textarea_set_text(ui_txtOfftime, String(nvsSystemEEPRom.systemLedOffTime).c_str());
    lv_textarea_set_text(ui_txtBrigtness, String(nvsSystemEEPRom.lcdBright).c_str());
}
extern void setTimeText();
void TabEventSetupTimeClick(lv_event_t * e)
{
	uint16_t selectedTab=0;
	setTimeText();
	lv_tabview_set_act(ui_TabView1,4,LV_ANIM_OFF);
	selectedTab = lv_tabview_get_tab_act(ui_TabView1);
	ESP_LOGW("UI","Set Time Tab selected %d",selectedTab);
}

void btnEventRunUps(lv_event_t * e)
{
	int token ;
	if (upsModbusData.HWState.Bit.CONVERTER_RUN_STOP_STATE ||
		upsModbusData.HWState.Bit.DC_DC_CONVERTER_RUN_STOP_STATE ||
		upsModbusData.HWState.Bit.INVERTER_RUN_STOP_STATE)
	{
	}
	else  //off 상태 이므로 RUN Command를 보낸다.
	{
		ESP_LOGW("UPS","----->btnEventRunUps 런 명령");
		upsModbusData.upsRun.upsRunCommandBit.UpsON ^= 1;
		//token = WriteHoldRegistor(UPSONOFF, upsModbusData.upsRun.upsRun, UPSONOFF);
		enqueueModbusCommand(UPSONOFF, upsModbusData.upsRun.upsRun, UPSONOFF);
		// if (token == 0)
		// 	showMessageLabel(_("Comm_Error"));
		// else
		// 	ESP_LOGI("MODUBS", "Received token %d..", token);
	}
}

void btnEventStopUps(lv_event_t * e)
{
	int token ;
	if (upsModbusData.HWState.Bit.CONVERTER_RUN_STOP_STATE ||
		upsModbusData.HWState.Bit.DC_DC_CONVERTER_RUN_STOP_STATE ||
		upsModbusData.HWState.Bit.INVERTER_RUN_STOP_STATE)
	{  // RUN 상태이므로 STOP를 보낸다
		ESP_LOGW("UPS","----->btnEventStopUps 스톱 명령");
		upsModbusData.upsRun.upsRunCommandBit.UpsOFF ^= 1;
		enqueueModbusCommand(UPSONOFF, upsModbusData.upsRun.upsRun, UPSONOFF);
		// token = WriteHoldRegistor(UPSONOFF, upsModbusData.upsRun.upsRun, UPSONOFF);
		// if (token == 0)
		// 	showMessageLabel(_("Comm_Error"));
		// else
		// 	ESP_LOGI("MODUBS", "Received token %d..", token);
	}
	else  //off 상태 이므로 RUN Command를 보낸다.
	{
	}

}


int checkValidation()
{
	uint32_t *p; 
	uint16_t inputTextId=0;
	uint32_t token ;
	p = (uint32_t  *)lv_obj_get_user_data(ui_txtTempory );
	inputTextId = *p >> 24; 
	*p = *p & 0x00ffffff;
	//NULL이면 정상으로 본다.
	if (p != NULL)
	{
		uint32_t consData = *p;
		if (consData == 0)
			return 1;
		uint32_t lowValue = consData >> 16;
		uint32_t highValue = consData & 0x0000FFFF;
		// if (String(lv_textarea_get_text(ui_txtInputArea)).length() > 0)
		uint16_t inputData = String(lv_textarea_get_text(ui_txtInputArea)).toInt();
		ESP_LOGW("EVENT", "User id %d value %d  %d - %d", inputTextId, inputData, lowValue, highValue);
		if (inputData < lowValue || inputData > highValue)
		{
			String str;
			str = "입력범위(";
			str += lowValue;
			str += "-";
			str += highValue;
			str += ")";
			if (inputData < lowValue)
				lv_textarea_set_text(ui_txtInputArea, String(lowValue).c_str());
			if (inputData > highValue)
				lv_textarea_set_text(ui_txtInputArea, String(highValue).c_str());
			showMessageLabel(str.c_str());
			return 0;
		}
		switch (inputTextId)
		{
		case BATCURR_REF:
		case BATVOL_REF:
		case OUTPUTVOL_REF:
		case INPUTVOLTGAIN:
		case INPUTCURRGAIN:
		case VDCLINKVOLTGAIN:
		case VBATVOLTGAIN:
		case BAT_CURRENT_GAIN:
		case INVERTER_VOLT_GAIN:
		case INVERTER_CURRENT_GAIN:
		case OUTPUT_CURRENT_GAIN:
		case HFMODE:
			enqueueModbusCommand(inputTextId,inputData ,inputTextId);
			// token = WriteHoldRegistor(inputTextId,inputData ,inputTextId);
			// if(token==0) showMessageLabel(_("Comm_Error"));
			// else ESP_LOGI("MODUBS", "Received token %d..",token );
			break;
		case EVENTTXTOFFTIME_:
			ESP_LOGI("SET", "Set Off Time %d minute ",inputData );
			nvsSystemEEPRom.systemLedOffTime = inputData ; 
			EEPROM.writeBytes(1, (const byte *)&nvsSystemEEPRom, sizeof(nvsSystemSet_t));
			EEPROM.commit();
  			//EEPROM.readBytes(1, (byte *)&nvsSystemEEPRom, sizeof(nvsSystemEEPRom));
			break;
		case BRIGHTNESSCONSTRAIN_:
			nvsSystemEEPRom.lcdBright = inputData ; 
			EEPROM.writeBytes(1, (const byte *)&nvsSystemEEPRom, sizeof(nvsSystemSet_t));
			EEPROM.commit();
			break;
		case SYSTEMYEAR:
			timeSave(S_YEAR,inputData);
			break;
		case SYSTEMMONTH:
			timeSave(S_MONTH,inputData);
			break;
		case SYSTEMDAY:
			timeSave(S_DAY,inputData);
			break;
		case SYSTEMHOUR:
			timeSave(S_HOUR,inputData);
			break;
		case SYSTEMMINUTE:
			timeSave(S_MIN,inputData);
			break;
		case SYSTEMSECOND:
			timeSave(S_SEC,inputData);
			break;
		default:
			break;
		}
	}
	return 1;
}
/*https://docs.lvgl.io/master/widgets/textarea.html*/
// void KeyBoardReadyEvent(lv_event_t * e){
// 	//ESP_LOGI("KEYBOARD","KeyBoardReadyEvent");
// 	//lv_textarea_set_cursor_pos(ui_txtInputArea,LV_TEXTAREA_CURSOR_LAST);
// 	//lv_obj_add_state(ui_txtInputArea, LV_STATE_FOCUSED); 
// }

void bntEnterEvent(lv_event_t *e)
{
	// lv_event_send(ui_btnAlarmPrev2,LV_EVENT_CLICKED,0);
	checkValidation();
	lv_obj_add_flag(ui_pnlKeyBoard, LV_OBJ_FLAG_HIDDEN);
	if (ui_txtTempory != nullptr)
	{
		// ui_txtTempory 이것은 해당 Text이다.
		lv_textarea_set_text(ui_txtTempory, lv_textarea_get_text(ui_txtInputArea));
		// ui_txtTempory.get
	}
}
void keyBoardValueChangedEvent(lv_event_t * e)
{
	lv_obj_add_state(ui_txtInputArea, LV_STATE_FOCUSED); 
	lv_obj_t *kb = lv_event_get_target(e);
	uint32_t btn_id = lv_keyboard_get_selected_btn(kb);
	const char *txt = lv_keyboard_get_btn_text(kb,btn_id);
 	int16_t    keyValue= String(lv_textarea_get_text(ui_txtInputArea)).toInt();
  	ESP_LOGI("DEBUG","ui_txtInputArea %d",keyValue);
	if(btn_id  ==  3)  //최소키가 눌리면..
	{
		lv_obj_add_flag(ui_pnlKeyBoard,LV_OBJ_FLAG_HIDDEN);
		// if(ui_txtTempory != nullptr){
		// 	//ui_txtTempory 이것은 해당 Text이다.
		// 	lv_textarea_set_text(ui_txtTempory ,lv_textarea_get_text( ui_txtInputArea)) ; 
		// }
		return;
	}
	if(btn_id  ==  11 || btn_id  ==  15)  //확인 키가 눌리면...
	{
		checkValidation();
		lv_obj_add_flag(ui_pnlKeyBoard,LV_OBJ_FLAG_HIDDEN);
		if(ui_txtTempory != nullptr){
			//ui_txtTempory 이것은 해당 Text이다.
			lv_textarea_set_text(ui_txtTempory ,lv_textarea_get_text( ui_txtInputArea)) ; 
			//ui_txtTempory.get
		}
	}
}

void changeKeyboardText()
{
	//ui_Keyboard1;
//   static const char * kb_map[] = {
// 	"1", "2", "3", _("CANCEL")/*LV_SYMBOL_CLOSE*/,"\n",
// 	"4", "5", "6", _("SAVE")/*LV_SYMBOL_OK*/ ,"\n",
// 	"7", "8", "9", _("BACKSPACE")/*LV_SYMBOL_BACKSPACE*/,"\n",
// 	"<"/*LV_SYMBOL_LEFT*/, "0", ">"/*LV_SYMBOL_RIGHT*/,"",  NULL
//      };		
  static const char * kb_map[] = {
	"1", "2", "3", LV_SYMBOL_CLOSE,"\n",
	"4", "5", "6", LV_SYMBOL_BACKSPACE,"\n",
	"7", "8", "9", LV_SYMBOL_OK ,"\n",
	LV_SYMBOL_LEFT, "0", LV_SYMBOL_RIGHT,LV_SYMBOL_OK ,  NULL
     };		
	
  static const lv_btnmatrix_ctrl_t kb_ctrl[] = 
  {
	4, 4, 4, 6, 
 	4, 4, 4, 6, 
   	4, 4, 4, 6, 
    4, 4, 4, /* LV_BTNMATRIX_CTRL_HIDDEN |*/ 6, 
  };
	//ui_Keyboard1 = lv_keyboard_create(ui_pnlKeyBoard);

	lv_keyboard_set_map(ui_Keyboard1,LV_KEYBOARD_MODE_USER_1,kb_map,kb_ctrl);
	lv_keyboard_set_mode(ui_Keyboard1, LV_KEYBOARD_MODE_USER_1);

	//lv_keyboard_set_mode(ui_Keyboard1, LV_KEYBOARD_MODE_NUMBER);
	lv_obj_set_width(ui_Keyboard1, lv_pct(100));
	lv_obj_set_height(ui_Keyboard1, lv_pct(80));
	lv_obj_set_x(ui_Keyboard1, -9);
	lv_obj_set_y(ui_Keyboard1, 29);
	lv_obj_set_align(ui_Keyboard1, LV_ALIGN_CENTER);
	lv_obj_set_flex_flow(ui_Keyboard1, LV_FLEX_FLOW_ROW);
	lv_obj_set_flex_align(ui_Keyboard1, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
	lv_obj_add_flag(ui_Keyboard1, LV_OBJ_FLAG_IGNORE_LAYOUT); /// Flags
	lv_obj_set_style_radius(ui_Keyboard1, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
	lv_obj_set_style_bg_color(ui_Keyboard1, lv_color_hex(0xCECACA), LV_PART_MAIN | LV_STATE_DEFAULT);
	lv_obj_set_style_bg_opa(ui_Keyboard1, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

	lv_obj_set_style_text_color(ui_Keyboard1, lv_color_hex(0x090808), LV_PART_ITEMS | LV_STATE_DEFAULT);
	lv_obj_set_style_text_opa(ui_Keyboard1, 255, LV_PART_ITEMS | LV_STATE_DEFAULT);
	//lv_obj_set_style_text_font(ui_Keyboard1, &ui_font_malgun26, LV_PART_ITEMS| LV_STATE_DEFAULT);
	lv_obj_set_style_text_font(ui_Keyboard1, &lv_font_montserrat_26, LV_PART_ITEMS| LV_STATE_DEFAULT);
}

    // lv_event_code_t event_code = lv_event_get_code(e);
    // lv_obj_t * target = lv_event_get_target(e);
    // if(event_code == LV_EVENT_PRESSED) {
    //     _ui_screen_change(&ui_SettingScreen, LV_SCR_LOAD_ANIM_MOVE_LEFT, 0, 0, &ui_SettingScreen_screen_init);
    // }
void scrSettingScreenLoaded(lv_event_t * e){
    _ui_screen_change(&ui_SettingScreen, LV_SCR_LOAD_ANIM_MOVE_LEFT, 0, 0, &ui_SettingScreen_screen_init);
	changeKeyboardText();
	lv_tabview_set_act(ui_TabView1,0,LV_ANIM_OFF);
	scrSettingScreen();

	//lv_tabview_set_act(ui_TabView1,1,LV_ANIM_OFF);
    //lv_obj_add_flag(ui_batSaveSetting, LV_OBJ_FLAG_HIDDEN );     /// Flags
	//_ui_flag_modify( ui_batSaveSetting , LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
}
void scrSettingScreen(){
  //설정화면 
  char tempstr[10];
  lv_textarea_set_text(ui_txtBatCurrSet, String(upsModbusData.Bat_Current_Ref).c_str()); //2-20 default 2
  lv_textarea_set_text(ui_txtBatVolSet, String(upsModbusData.Bat_Voltage_Ref).c_str()); //
  lv_textarea_set_text(ui_txtOutputVolSet, String(upsModbusData.Output_Voltage_Ref).c_str()); //
  lv_textarea_set_text(ui_txtHFMnBatFirstFaultUV, String(upsModbusData.HF_MODE).c_str()); //

//   if(upsModbusData.HF_MODE==1)
//     lv_obj_add_state( ui_txtHFMnBatFirstFaultUV, LV_STATE_CHECKED );     /// States
//   else 
//     lv_obj_clear_state(ui_txtHFMnBatFirstFaultUV,LV_STATE_CHECKED );


	sprintf(tempstr, "%d V", upsModbusData.Input_volt_rms);
	lv_label_set_text(ui_txtInputVoltGainLBL, tempstr);
  lv_textarea_set_text(ui_txtInputVoltGain, 
      String(upsModbusData.input_volt_gain).c_str()); //

	sprintf(tempstr, "%d A", upsModbusData.Input_current_rms);
	lv_label_set_text(ui_txtInputCurrGainLBL, tempstr);
  lv_textarea_set_text(ui_txtInputCurrGain, 
      String(upsModbusData.input_current_gain).c_str()); //

	sprintf(tempstr, "%d V", upsModbusData.inverter_volt_rms);
	lv_label_set_text(ui_txtInvVoltGainLBL, tempstr);
  lv_textarea_set_text(ui_txtInvVoltGain, 
      String(upsModbusData.inverter_volt_gain).c_str()); //

	sprintf(tempstr, "%d A", upsModbusData.inverter_current_rms);
	lv_label_set_text(ui_txtInvCurrGainLBL, tempstr);
  lv_textarea_set_text(ui_txtInvCurrGain, 
      String(upsModbusData.inverter_current_gain).c_str()); //

 
	sprintf(tempstr, "%d V", upsModbusData.bat_volt_rms);
	lv_label_set_text(ui_txtVbatVoltGainLBL, tempstr);
  lv_textarea_set_text(ui_txtVbatVoltGain, 
      String(upsModbusData.vbat_volt_gain).c_str()); //

	sprintf(tempstr, "%d A", upsModbusData.bat_current_rms);
	lv_label_set_text(ui_txtBatCurrGainLBL, tempstr);
  lv_textarea_set_text(ui_txtBatCurrGain, 
      String(upsModbusData.bat_current_gain).c_str()); //

	sprintf(tempstr, "%d A", upsModbusData.output_current_rms);
	lv_label_set_text(ui_txtOutputCurrGainLBL, tempstr);
  lv_textarea_set_text(ui_txtOutputCurrGain, 
      String(upsModbusData.output_current_gain).c_str()); //

	sprintf(tempstr, "%d V", upsModbusData.vdc_link_volt_rms);
	lv_label_set_text(ui_txtInputVdcLinkGainLBL, tempstr);
  lv_textarea_set_text(ui_txtInputVdcLinkGain, 
      String(upsModbusData.vdc_link_volt_gain).c_str()); //


// UPS RUN OFF 
	if (upsModbusData.HWState.Bit.CONVERTER_RUN_STOP_STATE ||
		upsModbusData.HWState.Bit.DC_DC_CONVERTER_RUN_STOP_STATE ||
		upsModbusData.HWState.Bit.INVERTER_RUN_STOP_STATE)
	{
		lv_obj_set_style_bg_color(ui_btnRunUps, lv_color_hex(0xF80D29), LV_PART_MAIN | LV_STATE_DEFAULT);
		lv_obj_set_style_bg_color(ui_btnStopUps1, lv_color_hex(0xCAC8C8), LV_PART_MAIN | LV_STATE_DEFAULT);
	}
	else{
		lv_obj_set_style_bg_color(ui_btnRunUps, lv_color_hex(0xCAC8C8), LV_PART_MAIN | LV_STATE_DEFAULT);
		lv_obj_set_style_bg_color(ui_btnStopUps1, lv_color_hex(0xF80D29), LV_PART_MAIN | LV_STATE_DEFAULT);
	}
}
void scrMeasureLoad()
{
	char tempstr[10];
	sprintf(tempstr, "%dV", upsModbusData.Input_volt_rms);
	lv_label_set_text(ui_lblInputVoltRms, tempstr);
	// String(upsModbusData.Input_volt_rms).c_str()); //

	sprintf(tempstr, "%dA", upsModbusData.Input_current_rms);
	lv_label_set_text(ui_lblInputCurrRms, tempstr);
	// String(upsModbusData.Input_current_rms).c_str()); //

	sprintf(tempstr, "%dV", upsModbusData.vdc_link_volt_rms);
	lv_label_set_text(ui_lblVdcLinkVoltRms, tempstr);
	// String(upsModbusData.vdc_link_volt_rms).c_str()); //

	sprintf(tempstr, "%dV", upsModbusData.bat_volt_rms);
	lv_label_set_text(ui_lblBatVoltRms, tempstr);
	// String(upsModbusData.bat_volt_rms).c_str()); //

	sprintf(tempstr, "%dA", upsModbusData.bat_current_rms);
	lv_label_set_text(ui_lblBatCurrentRms, tempstr);
	// String(upsModbusData.bat_current_rms).c_str()); //

	sprintf(tempstr, "%dV", upsModbusData.inverter_volt_rms);
	lv_label_set_text(ui_lblInvVoltRms, tempstr);
	// String(upsModbusData.inverter_volt_rms).c_str()); //

	sprintf(tempstr, "%dA", upsModbusData.inverter_current_rms);
	lv_label_set_text(ui_lblInvCurrentRms, tempstr);
	// String(upsModbusData.inverter_current_rms).c_str()); //

	sprintf(tempstr, "%dV", upsModbusData.output_volt_rms);
	lv_label_set_text(ui_lblOutputVoltRms, tempstr);
	// String(upsModbusData.output_volt_rms).c_str()); //
	// TAB2
	sprintf(tempstr, "%dA", upsModbusData.output_current_rms);
	lv_label_set_text(ui_lblOutputCurrRms, tempstr);
	// String(upsModbusData.output_current_rms).c_str()); //

	sprintf(tempstr, "%2.1fHz", upsModbusData.bypass_Frequency/10.0);
	lv_label_set_text(ui_lblInputFreq, tempstr);
	// String(upsModbusData.bypass_Frequency).c_str()); //

	sprintf(tempstr, "%2.1fHz", upsModbusData.inv_Frequency/10.0);
	lv_label_set_text(ui_lblInvFreq, tempstr);
	lv_label_set_text(ui_lblOutputFreq, tempstr);
	// String(upsModbusData.inv_Frequency).c_str()); //

	sprintf(tempstr, "%2.1fHz", upsModbusData.bypass_Frequency/10.0);
	lv_label_set_text(ui_lblBypassFreq, tempstr);
	// String(upsModbusData.bypass_Frequency).c_str()); //

	sprintf(tempstr, "%d%", upsModbusData.battery_capacity);
	lv_label_set_text(ui_lblBattCapacity, tempstr);
	// String(upsModbusData.battery_capacity).c_str()); //

	lv_label_set_text(ui_lblUpsInnerTemp,
					  String(upsModbusData.inv_internal_Temperature).c_str()); //
	// GAIN
	lv_label_set_text(ui_lblInputVoltGain,
					  String(upsModbusData.input_volt_gain).c_str()); //
	lv_label_set_text(ui_lblInputCurrGain,
					  String(upsModbusData.input_current_gain).c_str()); //
	lv_label_set_text(ui_lblVdcLinkVoltGain,
					  String(upsModbusData.vdc_link_volt_gain).c_str()); //
	lv_label_set_text(ui_lblVbatVoltGain,
					  String(upsModbusData.vbat_volt_gain).c_str()); //
	lv_label_set_text(ui_lblBatCurrentGain,
					  String(upsModbusData.bat_current_gain).c_str()); //
	lv_label_set_text(ui_lblInverterVoltGain,
					  String(upsModbusData.inverter_volt_gain).c_str()); //
	lv_label_set_text(ui_lblInvCurrGain,
					  String(upsModbusData.inverter_current_gain).c_str()); //
	lv_label_set_text(ui_lblOutputCurrGain,
					  String(upsModbusData.output_current_gain).c_str()); //
// offset 설정.
	lv_textarea_set_text(ui_txtInputVoltOffset,String(upsModbusData.input_volt_offset).c_str());
	lv_textarea_set_text(ui_txtInputCurrentOffset,String(upsModbusData.input_current_offset).c_str());
	lv_textarea_set_text(ui_txtVdcLinkVoltOffset,String(upsModbusData.vdc_link_volt_offset).c_str());
	lv_textarea_set_text(ui_txtBatVoltOffset,String(upsModbusData.bat_volt_offset).c_str());
	lv_textarea_set_text(ui_txtBatCurrentOffset,String(upsModbusData.bat_current_offset).c_str());
	lv_textarea_set_text(ui_txtInvVoltOffset,String(upsModbusData.inverter_volt_offset).c_str());
	lv_textarea_set_text(ui_txtInvCurrentOffset,String(upsModbusData.inverter_current_offset).c_str());
	lv_textarea_set_text(ui_txtOutCurrentOffset,String(upsModbusData.output_current_offset).c_str());
}
void scrMeasureLoadEvent(lv_event_t * e){
	scrMeasureLoad();
}


void CommonEevntProc(lv_event_t * e){
	 ui_txtTempory = lv_event_get_target(e);
    _ui_flag_modify( ui_pnlKeyBoard, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
	lv_textarea_set_text(ui_txtInputArea,lv_textarea_get_text(ui_txtTempory));
	//lv_textarea_set_placeholder_text(ui_txtInputArea,lv_textarea_get_text(ui_txtTempory));
	lv_obj_add_state(ui_txtInputArea, LV_STATE_FOCUSED); 
}
//입력값 제한 방법
/*
	id를 24~32사이에 기록한다.
	제한값을 하위 16, 상위 8 에 기록한다. 
	상위값이 작은값을 하위값이 큰값을 기록한다.
*/
uint32_t BatCurrsetConstrain=0x0000ffff;
void EventTxtBatCurrset(lv_event_t * e)
{
	ui_txtTempory = lv_event_get_target(e);
	int32_t id =  BATCURR_REF<<24;
	BatCurrsetConstrain += id;
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&BatCurrsetConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t BatVoltageConstrain=0x0000ffff;
void EventTxtBatVolSet(lv_event_t * e)
{
	int32_t id =  BATVOL_REF<<24;
	BatVoltageConstrain+= id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&BatVoltageConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t outVoltageConstrain=0x0000ffff;
void EventTxtOutputVolSet(lv_event_t * e)
{
	int32_t id =  OUTPUTVOL_REF<<24;
	outVoltageConstrain+= id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&outVoltageConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t hfmBatFirstFaultUVConstrain=0x0000ffff;
void EventTxtHFMnBatFirstFaultUV(lv_event_t * e)
{
	int32_t id =  HFMODE<<24;
	hfmBatFirstFaultUVConstrain+= id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&hfmBatFirstFaultUVConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t gainConstrain_1=0x000001F4;
void EventTxtInputVoltGain(lv_event_t * e)
{
	int32_t id =  INPUTVOLTGAIN <<24;
	gainConstrain_1 += id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&gainConstrain_1);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t gainConstrain_2=0x000001F4;
void EventTxtInputCurrGain(lv_event_t * e)
{
	int32_t id =  INPUTCURRGAIN <<24;
	gainConstrain_2 += id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&gainConstrain_2);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t gainConstrain_3=0x000001F4;
void EventTxtInputVdcLinkGain(lv_event_t * e)
{
	int32_t id =  VDCLINKVOLTGAIN <<24;
	gainConstrain_3 += id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&gainConstrain_3);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t gainConstrain_4=0x000001F4;
void EventTxtVbatVoltGain(lv_event_t * e)
{
	int32_t id =  VBATVOLTGAIN <<24;
	gainConstrain_4 += id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&gainConstrain_4);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t gainConstrain_5=0x000001F4;
void EventTxtBatCurrGain(lv_event_t * e)
{
	int32_t id =  BAT_CURRENT_GAIN<<24;
	gainConstrain_5 += id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&gainConstrain_5);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t gainConstrain_6=0x000001F4;
void EventTxtInvVoltGain(lv_event_t * e)
{
	int32_t id =  INVERTER_VOLT_GAIN<<24;
	gainConstrain_6 += id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&gainConstrain_6);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t gainConstrain_7=0x000001F4;
void EventTxtInvCurrGain(lv_event_t * e)
{
	int32_t id =  INVERTER_CURRENT_GAIN<<24;
	gainConstrain_7 += id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&gainConstrain_7);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t gainConstrain_8=0x000001F4;
void EventTxtOutputCurrGain(lv_event_t * e)
{
	int32_t id =  OUTPUT_CURRENT_GAIN<<24;
	gainConstrain_8 += id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&gainConstrain_8);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t offtimeConstrain=0x0000FFFF;
void EventTxtOfftime(lv_event_t * e)
{
	int32_t id =  EVENTTXTOFFTIME_ <<24;
	offtimeConstrain += id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&offtimeConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

uint32_t brightnessConstrain=0x005000FF;
void EventTxtBrigtness(lv_event_t * e)
{
	int32_t id =  BRIGHTNESSCONSTRAIN_ <<24;
	brightnessConstrain+= id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&brightnessConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 3);
	CommonEevntProc(e);
}

//uint32_t yearConstrain=0x07E8081A;
uint32_t yearConstrain=0x00180063;
void EventTxtYear(lv_event_t * e)
{
	int32_t id =  SYSTEMYEAR<<24;
	yearConstrain+= id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&yearConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 2);
	CommonEevntProc(e);
}

uint32_t monthConstrain=0x0001000C;
void EventTxtMonth(lv_event_t * e)
{
	int32_t id =  SYSTEMMONTH<<24;
	monthConstrain+= id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&monthConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 2);
	CommonEevntProc(e);
}

uint32_t dayConstrain=0x0001001F;
void EventTxtDay(lv_event_t * e)
{
	int32_t id =  SYSTEMDAY<<24;
	dayConstrain += id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&dayConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 2);
	CommonEevntProc(e);
}

uint32_t hourConstrain=0x00000017;
void EventTxtHour(lv_event_t * e)
{
	int32_t id =  SYSTEMHOUR<<24;
	hourConstrain+= id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&hourConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 2);
	CommonEevntProc(e);
}

uint32_t minuteConstrain=0x0000003B;
void EventTxtMinute(lv_event_t * e)
{
	int32_t id =  SYSTEMMINUTE<<24;
	minuteConstrain+= id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&minuteConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 2);
	CommonEevntProc(e);
}

uint32_t secondConstrain=0x0000003B;
void EventTxtSecond(lv_event_t * e)
{
	int32_t id =  SYSTEMSECOND <<24;
	secondConstrain+= id;
	ui_txtTempory = lv_event_get_target(e);
	lv_obj_set_user_data(ui_txtTempory ,(uint32_t *)&secondConstrain);
	lv_textarea_set_max_length(ui_txtInputArea , 2);
	CommonEevntProc(e);
}

void setLogTextArea(lv_obj_t *obj,upsLog  *upslog,directionType_t direction)
{
	upslog_t log;
	String retStr;
	retStr = "";
	retStr = upslog->readCurrentLog(direction,true);

	//ESP_LOGW("UI EventLog","log \n%s",retStr.c_str() );
	lv_textarea_set_text(obj, retStr.c_str());
	while( lv_textarea_get_cursor_pos(obj)){
		//ESP_LOGW("UI EventAlarm","lv_textarea_cursor_up%d",lv_textarea_get_cursor_pos(ui_eventTextArea) );
		lv_textarea_cursor_up(obj);
	}
}
std::string showEventTabTitle()
{
	std::string strMessage;
	strMessage="";
	if (upslogEvent.logCount > 0)
	{
		strMessage.append(_("eventHistory"));
		strMessage.append("(");
		int curPage=0;
		curPage =  upslogEvent.getCurrentMemoryPage();
		curPage = curPage == 0 ? 1:curPage;
		strMessage.append(std::to_string(curPage));
		strMessage.append("/");
		strMessage.append(std::to_string(upslogEvent.totalPage));
		strMessage.append(")");
		lv_tabview_rename_tab(ui_TabView2, 1, strMessage.c_str());
	}
	else{
		strMessage="";
		strMessage.append(_("eventHistory"));
		lv_tabview_rename_tab(ui_TabView2, 1, strMessage.c_str());
	}
	return strMessage;
};
void evtLogScreenLoaded(lv_event_t * e){
	uint16_t selectedTab=0;
	selectedTab = lv_tabview_get_tab_act(ui_TabView2);
	//ESP_LOGW("UI","Tab selected %d",selectedTab);
	upslog_t log;
	//if(selectedTab ==0 )
	{
		setLogTextArea(ui_eventTextArea,&upslogEvent,CURRENTLOG);
		//lv_textarea_set_text(ui_eventTextArea, retStr.c_str() );
	}
	//else 
	{
		setLogTextArea(ui_alarmTextArea,&upslogAlarm,CURRENTLOG);
		//lv_textarea_set_text(ui_alarmTextArea, retStr.c_str() );
		//ESP_LOGW("UI EventAlarm","log %s",retStr.c_str() );
	}
    //lv_textarea_set_cursor_pos(ui_alarmTextArea,0);
	//lv_textarea_set_cursor_pos(ui_eventTextArea,LV_TEXTAREA_CURSOR_);
	while( lv_textarea_get_cursor_pos(ui_eventTextArea)){
		//ESP_LOGW("UI EventAlarm","lv_textarea_cursor_up%d",lv_textarea_get_cursor_pos(ui_eventTextArea) );
		lv_textarea_cursor_up(ui_eventTextArea);
	}
	while( lv_textarea_get_cursor_pos(ui_alarmTextArea)){
		//ESP_LOGW("UI EventAlarm","lv_textarea_cursor_up%d",lv_textarea_get_cursor_pos(ui_alarmTextArea) );
		lv_textarea_cursor_up(ui_alarmTextArea);
	}
	showEventTabTitle();
	std::string strMessage;
	if (upslogAlarm.logCount > 0)
	{
		strMessage = "";
		strMessage.append(_("alarmStatus"));
		strMessage.append("(");
		strMessage.append(std::to_string(upslogAlarm.getCurrentMemoryPage()));
		strMessage.append("/");
		strMessage.append(std::to_string(upslogAlarm.totalPage));
		strMessage.append(")");
		lv_tabview_rename_tab(ui_TabView2, 0, strMessage.c_str());
	}
	else
	{
		strMessage = "";
		strMessage.append(_("alarmStatus"));
		lv_tabview_rename_tab(ui_TabView2, 0, strMessage.c_str());
	}

	//lv_obj_set_scroll_snap_y(ui_eventTextArea,LV_SCROLL_SNAP_START);
	//lv_obj_set_scroll_snap_y(ui_alarmTextArea,LV_SCROLL_SNAP_START);
	
    //lv_obj_scroll_to(ui_alarmTextArea,(lv_coord_t )0,(lv_coord_t )0,LV_ANIM_OFF);
	// lv_event_t lpl;
	// lv_obj_t * cont = ui_eventTextArea;
	// lv_obj_add_event_cb(cont, scroll_event_cb, LV_EVENT_SCROLL, NULL);
	//lv_event_send(ui_alarmTextArea,LV_SCROLL_SNAP_START);
	//ESP_LOGW("UI EventAlarm","cursor %d",lv_textarea_get_cursor_pos(ui_alarmTextArea) );
}
void EventLogNext(lv_event_t *e) /* 이전 버튼 */
{
	if(upslogEvent.logCount == 0) return;
	//로그가 1개라도 있으면 TotalPage는 1이어야 한다.
	//이때 CurrentMemoryPage는 0이지만 1를 리턴 받는다.
	if(upslogEvent.getCurrentMemoryPage() == upslogEvent.totalPage) 
	{
		showEventTabTitle();
		return;
	}
	// if( upslogEvent.logCount % LOG_PER_PAGE == 0 && upslogEvent.getCurrentMemoryPage() + 1 == upslogEvent.totalPage)
	// {
	// 	return;
	// };
	uint16_t selectedTab = 0;
	selectedTab = lv_tabview_get_tab_act(ui_TabView2);
	if (selectedTab == 0){
		//ESP_LOGI("EVENT", "Alarm Next Selected");
		setLogTextArea(ui_alarmTextArea, &upslogAlarm,NEXTLOG);
	}
	else{
		//ESP_LOGI("EVENT", "logEvent  Next Selected");
		setLogTextArea(ui_eventTextArea, &upslogEvent,NEXTLOG);
	}
	std::string strMessage;
	showEventTabTitle();
	if (upslogAlarm.logCount > 0)
	{
		strMessage = "";
		strMessage.append(_("alarmStatus"));
		strMessage.append("(");
		strMessage.append(std::to_string(upslogAlarm.getCurrentMemoryPage()));
		strMessage.append("/");
		strMessage.append(std::to_string(upslogAlarm.totalPage));
		strMessage.append(")");
		lv_tabview_rename_tab(ui_TabView2, 0, strMessage.c_str());
	}
	else{
		strMessage = "";
		strMessage.append(_("alarmStatus"));
		lv_tabview_rename_tab(ui_TabView2, 0, strMessage.c_str());
	}
}
void EventLogPrev(lv_event_t *e) /* 다음 버튼*/
{

	uint16_t selectedTab = 0;
	selectedTab = lv_tabview_get_tab_act(ui_TabView2);
	if (selectedTab == 0)
	{
		ESP_LOGI("EVENT", "Alarm Prev Selected");
		setLogTextArea(ui_alarmTextArea, &upslogAlarm, PREVLOG);
	}
	else
	{
		ESP_LOGI("EVENT", "logEvent  Prev Selected");
		setLogTextArea(ui_eventTextArea, &upslogEvent, PREVLOG);
	}

	std::string strMessage;
	showEventTabTitle();
	if (upslogAlarm.logCount > 0)
	{
		strMessage = "";
		strMessage.append(_("alarmStatus"));
		strMessage.append("(");
		strMessage.append(std::to_string(upslogAlarm.getCurrentMemoryPage()));
		strMessage.append("/");
		strMessage.append(std::to_string(upslogAlarm.totalPage));
		strMessage.append(")");
		lv_tabview_rename_tab(ui_TabView2, 0, strMessage.c_str());
	}
	else{
		strMessage = "";
		strMessage.append(_("alarmStatus"));
		lv_tabview_rename_tab(ui_TabView2, 0, strMessage.c_str());
	}
}

void btnAlarmRunStopAtLog(lv_event_t * e){
	upslogAlarm.runBuzzStatus =upslogAlarm.runBuzzStatus  ? 0:1;
	upsModbusData.upsRun.upsRunCommandBit.ALARM_RESET = upsModbusData.upsRun.upsRunCommandBit.ALARM_RESET ? 0: 1;
	enqueueModbusCommand(UPSONOFF, upsModbusData.upsRun.upsRun, UPSONOFF);
	// int token = WriteHoldRegistor(UPSONOFF, upsModbusData.upsRun.upsRun, UPSONOFF);
	// ESP_LOGI("MODUBS", "Received token %d..",token );
}
void btnAlarmRunStop(lv_event_t * e){
 	ESP_LOGI("UI","AlarmRunStop Animation start");
	upslogAlarm.runBuzzStatus =upslogAlarm.runBuzzStatus  ? 0:1;
	  //lv_anim_del_all();
}

void pnlNothingEvent(lv_event_t * e){
  ESP_LOGI("EVT","Event Received for chkbox");
  const char * str = lv_obj_get_state(ui_txtHFMnBatFirstFaultUV) & LV_STATE_CHECKED ? "Checked" : "Unchecked";
  ESP_LOGI("CHECKBOX","%s",str );
  int token = millis();
  lv_state_t state = lv_obj_get_state(ui_txtHFMnBatFirstFaultUV) & LV_STATE_CHECKED ;
  enqueueModbusCommand(HFMODE, state, token );
  // token = WriteHoldRegistor(HFMODE, state, token );
}
void pnlhfModeClickEvent(lv_event_t *e)
{
	if (lv_obj_get_state(ui_txtHFMnBatFirstFaultUV) & LV_STATE_CHECKED)
		lv_obj_clear_state(ui_txtHFMnBatFirstFaultUV, LV_STATE_CHECKED);
	else
		lv_obj_add_state(ui_txtHFMnBatFirstFaultUV, LV_STATE_CHECKED); /// States
	lv_event_send(ui_txtHFMnBatFirstFaultUV, LV_EVENT_CLICKED, 0);
}
void hfModeValueChangedEvent(lv_event_t * e){
  lv_event_send(ui_pnlNothing, LV_EVENT_CLICKED, 0);
  //lv_event_send(ui_pnlNothing,LV_EVENT_CLICKED,0);
}
	// int32_t bret;
  	// for(int i =0;i<100;i++ ){
  	// 	lv_timer_handler(); /* let the GUI do its work */
	// 	delay(10);
	// }; /* let the GUI do its work */
  	// //lv_timer_handler(); /* let the GUI do its work */
	// lv_obj_add_flag(ui_lblMessage,LV_OBJ_FLAG_HIDDEN);
	// lv_obj_t *ui_lblMessage;
	// ui_lblMessage = lv_label_create(ui_SettingScreen);
	// lv_obj_set_width(ui_lblMessage, lv_pct(70));
	// lv_obj_set_height(ui_lblMessage, lv_pct(30));
	// lv_obj_set_align(ui_lblMessage, LV_ALIGN_CENTER);
	// lv_label_set_text(ui_lblMessage, _("SAVED"));
	// lv_obj_add_flag(ui_lblMessage, /*LV_OBJ_FLAG_HIDDEN | */ LV_OBJ_FLAG_FLOATING); /// Flags
	// //_ui_flag_modify( ui_pnlKeyBoard, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
	// lv_obj_set_scrollbar_mode(ui_lblMessage, LV_SCROLLBAR_MODE_OFF);
	// lv_obj_set_style_text_color(ui_lblMessage, lv_color_hex(0x0921E1), LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_text_opa(ui_lblMessage, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_text_align(ui_lblMessage, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_radius(ui_lblMessage, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_bg_color(ui_lblMessage, lv_color_hex(0xB4A8A8), LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_bg_opa(ui_lblMessage, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_border_color(ui_lblMessage, lv_color_hex(0x000000), LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_border_opa(ui_lblMessage, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_border_width(ui_lblMessage, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_pad_left(ui_lblMessage, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_pad_right(ui_lblMessage, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_pad_top(ui_lblMessage, 20, LV_PART_MAIN | LV_STATE_DEFAULT);
	// lv_obj_set_style_pad_bottom(ui_lblMessage, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
	//lv_obj_del(ui_lblMessage);
  //chkHFMode
  //lv_obj_add_state( ui_chkHFMode, LV_STATE_CHECKED );     /// States
  //lv_obj_clear_state(ui_chkHFMode,LV_STATE_CHECKED );
  //lv_state_t state = lv_obj_get_state( ui_chkHFMode);
	// upsModbusData.upsRun.upsRunCommandBit.UpsOFF = 0;
	// uint16_t waitingCount = 0;
	// while (!getDataReady())
	// {
	// 	vTaskDelay(100);
	// 	ESP_LOGI("MODUBS", "Wating...%d", waitingCount++);
	// }
	// ESP_LOGI("MODUBS", "Received %d..", getReceiveToken());
	// gettimeofday(&tmv, NULL);
  	// // time_t now = mktime(&nowTime);
	// // timeval tVal;
	// // tVal.tv_sec = now;
	// // settimeofday(&tVal,NULL);
	// upsModbusData.upsRun.upsRunCommandBit.UpsOFF = 1;
	// uint16_t waitingCount = 0;
	// while (!getDataReady())
	// {
	// 	vTaskDelay(100);
	// 	ESP_LOGI("MODUBS", "Wating...%d..", waitingCount++);
	// }
	// ESP_LOGI("MODUBS", "Received %d ", getReceiveToken());
	//ESP_LOGI("LVGL","%d %d",btn_id ,txt);
	//if(strcmp(txt,1007180992)== 0){